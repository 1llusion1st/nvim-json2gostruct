-- ```lua
require("os")

local decode_json

if vim.json ~= nil and vim.json.decode ~= nil then
  decode_json = function(raw)
    return vim.json.decode(raw)
  end

else
  cjson = require("cjson")
  decode_json = function(raw)
    return cjson.decode(raw)
  end
end

io = require("io")
math = require("math")

local buf, win
local position = 0

function dump(o)
   if type(o) == 'table' then
      local s = '{ '
      for k,v in pairs(o) do
         if type(k) ~= 'number' then k = '"'..k..'"' end
         s = s .. '['..k..'] = ' .. dump(v) .. ','
      end
      return s .. '} '
   else
      return tostring(o)
   end
end

function table.shallow_copy(t)
  local t2 = {}
  for k,v in pairs(t) do
    t2[k] = v
  end
  return t2
end

local types_map = {}
function init_types_map()
	types_map["userdata"] = {false, false, "interface{}"}
	types_map[type("")] = {false, false, "string"}
	types_map[type(true)] = {false, false, "bool"}
	types_map["number"] = function(n, name)
		if n ~= math.floor(n) then
			return {false, false, "float64"}
		else
			return {false, false, "int64"}
		end
	end
	types_map["table"] = get_table_type
end
function get_table_type(t, name)
	if #t > 0 then
		-- processing array
		local el_type = "struct"
		el_type = type(t[1])
		if el_type ~= "table" then
			_, _, el_type = get_data_type(t[1], name)
		else
			el_type = "struct"
		end
		return {true, true, "[]"..el_type}
	else
		-- processing obj
		return {true, false,  "struct"}
	end
end
init_types_map()

function get_data_type(obj, name)
	-- print("calculating type of obj: ", type(obj), obj, "name: ", name)
	if obj == nil then return false, false, "interface{}" end
	local item = types_map[type(obj)]

	-- print("calculated type of " .. type(obj) .. " = ", item)
	if type(item) == "function" then
		item = item(obj, name)
		return item[1], item[2], item[3]

	else
		return item[1], item[2], item[3]
	end
end

function is_array(tbl)
	-- print("is_array called: ", dump(tbl))

	if tbl == nil then return false end
	-- print("len: ", #tbl)
	if #tbl > 0 then return true end
	for k, _ in pairs(tbl) do
		-- print("k = ", k, type(k))
		if type(k) ~= "number" then return false end
	end
	return true
end

function is_array_simple(tbl)
	if tbl == nil then return false end
	local t = type(tbl[1])
	if t == "userdata" then return true end
	if t == "table" then return false end
	return true
end

function is_array_empty(tbl)
	if tbl == nil then return false end
	return #tbl == 0
end

function convert_json_to_go_struct_in_memory(struct_name, json_table)
	if vim.g.debug_print == 1 then
		print("convert_json_to_go_struct_in_memory called: " .. dump(json_table))
	end
	local results = convert_json_to_gostruct(struct_name, json_table)
	return results
end

function convert_json_to_gostruct(struct_name, json_table, result_agregator, level, path)
	if level == nil then level = 0 end
	local prefix = (" "):rep(level * 4)
	
	if vim.g.debug_print == 1 then
		print("\n*\n*\n")
		print(prefix .. "convert_json_to_gostruct", struct_name, json_table)
	end

	local is_arr = is_array(json_table)
	local is_simple = is_array_simple(json_table)
	local is_empty = is_array_empty(json_table)
	if vim.g.debug_print == 1 then
		print(prefix .. "0. is_arr: ", is_arr, "is_simple: ", is_simple, "is_empty: ", is_empty)
	end

	-- root call - initialize variables
	if struct_name == nil then
		struct_name = "Autogenerated"
	end

	if path == nil then path = {} end

	local parse_selection = json_table == nil

	if result_agregator == nil then
		local path = {}

		local text
		local s_buf
		local s_row, s_col
		local e_row, e_col

		if parse_selection then
			text = get_visual_selection()
			-- print("selection:", text, type(text))
			s_buf, s_row, s_col, _ = unpack(vim.fn.getpos("'<"))
			_, e_row, e_col, _ = unpack(vim.fn.getpos("'>"))
			json_table = decode_json(text)
			if json_table == nil then
				print(prefix .."can't decode json")
				return
			end
		end
		if vim.g.debug_print == 1 then
			print("0. json_table:", json_table, type(json_table), dump(json_table))
		end
		local result_agregator = {}

		is_arr = is_array(json_table)
		is_simple = is_array_simple(json_table)
		is_empty = is_array_empty(json_table)
		if vim.g.debug_print == 1 then
			print(prefix .."1. is_arr: ", is_arr, "is_simple: ", is_simple, "is_empty: ", is_empty)
		end

		if not is_arr then

			-- OBJECT
			if vim.g.debug_print == 1 then
				print(prefix .. "PROCESSING AS OBJECT ")
			end
			table.insert(result_agregator, "type ".. struct_name .. " struct {")
			convert_json_to_gostruct("", json_table, result_agregator, 1, path)
			table.insert(result_agregator, "}")

		elseif is_arr and not is_empty and not is_simple then
			
			-- ARRAY of OBJECT
			if vim.g.debug_print == 1 then
				print(prefix .. "PROCESSING AS ARRAY of OBJECT ")
			end
						table.insert(result_agregator, "type ".. struct_name .. " []struct {")
			convert_json_to_gostruct("", json_table[1], result_agregator, 1, path)
			table.insert(result_agregator, "}")

		elseif is_arr and not is_empty and is_simple then

			-- ARRAY of TYPE
			if vim.g.debug_print == 1 then
				print(prefix .. "PROCESSING AS ARRAY of TYPE ")
			end
						_, _, typ = get_data_type(json_table[1])
			table.insert(result_agregator, "type ".. struct_name .. " []"..typ)

		elseif is_arr then

			-- EMPTY ARRAY
			if vim.g.debug_print == 1 then
				print(prefix .. "PROCESSING AS ARRAY EMPTY ")
			end
			table.insert(result_agregator, "type ".. struct_name .. " []".."interface{}")

		end

		-- print("s_row, s_col: ", s_row, s_col, "\ne_row, e_col: ", e_row, e_col)
		-- Keeps trailing visual selection
		if parse_selection then
			vim.api.nvim_buf_set_lines(s_buf, s_row - 1, e_row, false, result_agregator)
			vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes('<esc>', true, false, true), 'x', false)
		end
		return result_agregator
	end
	-- running nodes parser
	if vim.g.debug_print == 1 then
		print(prefix .. "processing json_table: ", type(json_table), json_table, " result_agregator: ", type(result_agregator), result_agregator)
		print(prefix .. "path: ", dump(path))
		print(prefix .."table: ", dump(json_table))
	end
	local max_name_len = 6
	local max_type_len = 13 -- []interface{}
	for key, val in pairs(json_table) do
		if vim.g.debug_print == 1 then
			print(prefix .. "processing ", key, val)
		end
		local name = to_camel_case(key)
		local composed, array, typ = get_data_type(val, name)
		if vim.g.debug_print == 1 then
			print(prefix .."composed", composed, "array", array, "typ", typ)
		end
		if #name > max_name_len then max_name_len = #name end
		if #typ > max_type_len then max_type_len = #typ end
	end
	local fmt = string.format("%%-%ds    %%-%ds    `json:\"%%s\"`", max_name_len, max_type_len)
	local fmt_composed = string.format("%%-%ds    %%-%ds {", max_name_len, max_type_len)
	local fmt_composed_type = string.format("%%-%ds    %%-%ds    `json:\"%%s\"`", max_name_len, max_type_len)
	local fmt_composed_empty = string.format("%%-%ds    %%-%ds    `json:\"%%s\"`", max_name_len, max_type_len)
	
	if vim.g.debug_print == 1 then
		print(prefix .. "GENERATING KEYs ...")
	end
	
	for key, value in pairs(json_table) do
		local currentPath = table.shallow_copy(path)
		if vim.g.debug_print == 1 then
			print(prefix .. "key: ", key, "value: ", type(value), value)
		end
		local name = to_camel_case(key)
		local composed, array, typ = get_data_type(value, name)
		if vim.g.debug_print == 1 then
			print(prefix .. "composed:", composed, "array:", array, "typ:", typ)
		end
		if options ~= nil then
			if meta ~= nil then
			end
		end
		if composed then
			-- HANDLE TABLE - ARRAY OR OBJECT
			is_arr = is_array(value)
			is_simple = is_array_simple(value)
			is_empty = is_array_empty(value)
			if vim.g.debug_print == 1 then
				print(prefix .. "V. is_arr: ", is_arr, " is_simple: ", is_simple, " is_empty:", is_empty)
			end
						
			if is_arr == false then
				if vim.g.debug_print == 1 then
					print(prefix .. "PROCESSING AS OBJECT " .. key)
				end
				
				-- OBJECT
				table.insert(result_agregator,
					prefix .. string.format(
						fmt_composed, name, typ))
				convert_json_to_gostruct(
					"", value, result_agregator, level + 1, currentPath)
				table.insert(result_agregator,
					prefix .. string.format("}    `json:\"%s\"`", key))

			else
				table.insert(currentPath, "[]")

				if is_arr and not is_empty and not is_simple then
			
					-- ARRAY of OBJECT
					if vim.g.debug_print == 1 then
						print(prefix .. "PROCESSING AS ARRAY of OBJECT " .. key)	
					end
					
					table.insert(result_agregator,
						prefix .. string.format(
							fmt_composed, name, typ))
					convert_json_to_gostruct(
						"", value[1], result_agregator, level + 1, currentPath)
					table.insert(result_agregator,
						prefix .. string.format("}    `json:\"%s\"`", key))

				elseif is_arr and not is_empty and is_simple then
					if vim.g.debug_print == 1 then
						print(prefix .. "PROCESSING AS ARRAY of TYPE " .. key)
					end
					
					-- ARRAY of TYPE
					table.insert(result_agregator,
						prefix .. string.format(
							fmt_composed_type, name, typ, key))

				elseif is_arr and is_empty then

					-- EMPTY ARRAY
					if vim.g.debug_print == 1 then
						print(prefix .. "PROCESSING AS ARRAY EMPTY " .. key)
					end
	
					table.insert(result_agregator,
						prefix .. string.format(
							fmt_composed_empty, name, "[]interface{}", key))

				end
			end
			-- END IF COMPOSED
		else
			table.insert(
				result_agregator, 
				prefix .. string.format(
					fmt, name, typ, key))
		end

	end
	return result_agregator
end

function gsub_upper(str, p, s, e, m)
	-- print("gsub_upper called with '" .. str .. "'")
	local new_str = str
	while true do
		local s, e, m = str:find(p)
		if m == nil then return str end
		new_str = str:gsub(p, m:upper(), 1)
		if str == new_str then return new_str end
		-- print("new_str = '" .. new_str .. "'")
		str = new_str
	end
end

function gsub(str, p, s, e, m)
	-- print("gsub called with '" .. str)
	local new_str = str
	while true do
		local s, e, m = str:find(p)
		if m == nil then return str end
		new_str = str:gsub(p, m, 1)
		-- print("new_str = '" .. new_str .. "'")
		if str == new_str then return new_str end
		str = new_str
	end
end

function to_camel_case(key)
	key = key:gsub("-", "_")
	local patterns = {
		{
			pattern = "__+([a-z])",
			-- func = function(str, p, s, e, m) return str:gsub(p, m:upper()) end
			func = function(str, p, s, e, m) return gsub_upper(str, p, s, e, m) end
		},
		{
			pattern = "_+([a-z])",
			-- func = function(str, p, s, e, m) return str:gsub(p, m:upper()) end
			func = function(str, p, s, e, m) return gsub_upper(str, p, s, e, m) end
		},
		{
			pattern = "__+([A-Z])",
			-- func = function(str, p, s, e, m) return str:gsub(p, m) end
			func = function(str, p, s, e, m) return gsub(str, p, s, e, m) end
		},
		{
			pattern = "_+([A-Z])",
			-- func = function(str, p, s, e, m) return str:gsub(p, m) end
			func = function(str, p, s, e, m) return gsub(str, p, s, e, m) end
		},
		{
			pattern = "^([a-z])",
			-- func = function(str, p, s, e, m) return str:gsub(p, m:upper()) end
			func = function(str, p, s, e, m) return gsub_upper(str, p, s, e, m) end
		},
		{
			pattern = "^([_\\-0-9])",
			func = function(str, p, s, e, m) return str:gsub(p, "F_" .. m) end
		}
	}
	for _, pattern in ipairs(patterns) do
		while true do
			local s, e, match = key:find(pattern.pattern)
			-- print("key before: ", key)
			-- print("pattern: ", pattern.pattern, "s: ", s, "e: ", e, "match: ", match)
			if match == nil then break end
			key = pattern.func(key, pattern.pattern, s, e, match)
			-- print("key after: ", key)
		end
	end
	return key
end

function get_visual_selection()
  -- print("get_visual_selection endtered")
  local s_start = vim.fn.getpos("'<")
  local s_end = vim.fn.getpos("'>")
  local n_lines = math.abs(s_end[2] - s_start[2]) + 1
  -- print("n_lines = ", n_lines)
  local lines = vim.api.nvim_buf_get_lines(0, s_start[2] - 1, s_end[2], false)
  lines[1] = string.sub(lines[1], s_start[3], -1)
  if n_lines == 1 then
    lines[n_lines] = string.sub(lines[n_lines], 1, s_end[3] - s_start[3] + 1)
  else
    lines[n_lines] = string.sub(lines[n_lines], 1, s_end[3])
  end
  return table.concat(lines, '\n')
end

-- print(to_camel_case("rpc_network_info"))

return {
	Json2GoStruct = convert_json_to_gostruct,
	Json2GoStructExt = function(params)
		print(params)
	end,
	to_camel_case = to_camel_case,
	decode_json = decode_json,
	convert_json_to_go_struct = convert_json_to_gostruct,
	convert_json_to_go_struct_in_memory = convert_json_to_go_struct_in_memory
}
-- ```
